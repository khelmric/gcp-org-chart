<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/x-icon" href="/static/favicon.png">
    <title>GCP Org Chart Viewer</title>
    <script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>
    <link rel="stylesheet" href="/static/style.css">
</head>
<body>
    <header>
        <div class="left">
            <img src="/static/favicon.png" width="40" height="40">
            <h2>GCP Org Chart Viewer</h2>
        </div>

        <div id="controls">
            <button id="theme-toggle" type="button" style="margin-right: 12px;" aria-label="Toggle dark mode" title="Toggle dark mode">ðŸŒ™</button>
            <span style="padding-right: 20px">
                {% if current_account == "unauthenticated user" %}
                    ðŸ”´ {{ current_account }}
                {% else %}
                    ðŸŸ¢ {{ current_account }}
                {% endif %}
            </span><br>
        </div>
    </header>
    <config>
        <div id="config-div" class="configDiv">
            <form method="get" id="config_form" action="/" style="display: inline;" onsubmit="return showLoadingSpinner();">
                <section class="form-row">
                    <label for="resourceId"><b>Resource ID:</b></label>
                    <input type="text" class="section-input" id="resourceId" name="resourceId" autofocus value="{{ resource_id }}"  style="width: 17em">
                    <button type="submit" id="load-resources" style="display: none;" aria-hidden="true">Load</button>
                    <span class="divider" aria-hidden="true"></span>
                    <label for="search-input"><b>Search:</b></label>
                    <input type="text" id="search-input" class="search-input" disabled>
                    <button id="focus-node" type="button" style="margin-left: 8px;" disabled>Focus</button>
                    <button id="toggle-visibility" type="button" style="margin-left: 8px;" disabled>Hide</button>
                    <button id="delete-node" type="button" style="margin-left: 8px;" disabled>Delete</button>
                    <button id="undo-action" type="button" style="margin-left: 6px;" disabled aria-label="Undo" title="Undo">â†º</button>
                    <button id="redo-action" type="button" style="margin-left: 6px;" disabled aria-label="Redo" title="Redo">â†»</button>
                    <button id="restore-chart" type="button" style="margin-left: 6px;" disabled>Reset all</button>
                    <button id="save-chart" type="button" style="margin-left: 6px;" disabled>Save</button>
                </section>
                <section>
                    <span id="error_msg" style="color: red;vertical-align: top;visibility: {{ 'visible' if error_msg else 'hidden' }};">{{error_msg|safe}}</span>
                </section>
            </form>
        </div>
    </config>
    <main>
        <div id="loading">
            <p>Loading, please wait...</p>
            <img src="{{ url_for('static', filename='loading.gif') }}" alt="Loading...">
        </div>
        <div id="report" style="visibility: hidden;">
            <div id="resource-hierarchy-chart-scale">
                <div id="resource-hierarchy-chart"></div>
            </div>
        </div>
    
    </main>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script>
        // SHOW LOADING ////////////////////////////////////////////

        function showLoadingSpinner() {
            document.getElementById('error_msg').style.visibility = 'hidden';
            document.getElementById("report").style.visibility = "hidden";   
            document.getElementById('loading').style.display = 'block';

            return true;
        }

        // ORG CHART //////////////////////////////////////////////

        function drawOrgChart() {
            const container = document.getElementById('resource-hierarchy-chart');
            if (!container) {
                return;
            }

            const deleteButton = document.getElementById("delete-node");
            const restoreButton = document.getElementById("restore-chart");
            const saveButton = document.getElementById("save-chart");
            const searchInput = document.getElementById("search-input");
            const focusButton = document.getElementById("focus-node");
            const toggleButton = document.getElementById("toggle-visibility");
            const undoButton = document.getElementById("undo-action");
            const redoButton = document.getElementById("redo-action");
            const resourceIdValue = "{{ resource_id }}";

            const chartDataRaw = {{ resource_hierarchy_chart_data|tojson|safe }};
            let originalRows = [];
            if (chartDataRaw) {
                try {
                    originalRows = JSON.parse(chartDataRaw);
                } catch (err) {
                    console.error("Failed to parse chart data JSON", err);
                }
            }

            let currentRows = originalRows.slice();
            let selectedNodeId = "";
            const deletedNodeIds = new Set();
            const collapsedNodeIds = new Set();
            let focusNodeId = "";
            const hiddenNodeSnapshots = new Map();
            const undoStack = [];
            const redoStack = [];

            let chart = null;

            const buildDataTable = (rows) => {
                var data = new google.visualization.DataTable();
                data.addColumn('string', 'Name');
                data.addColumn('string', 'Manager');
                data.addColumn('string', 'ToolTip');
                if (rows.length > 0) {
                    data.addRows(rows);
                }
                return data;
            };

            const clearSelectionHighlight = () => {
                container
                    .querySelectorAll(".org-chart-node.node-selected")
                    .forEach((node) => node.classList.remove("node-selected"));
            };

            const applySelectionHighlight = () => {
                clearSelectionHighlight();
                if (!selectedNodeId) {
                    return;
                }
                const node = container.querySelector(`.org-chart-node[data-node-id="${selectedNodeId}"]`);
                if (node) {
                    node.classList.add("node-selected");
                }
            };

            const serializeState = () => {
                const hiddenEntries = Array.from(hiddenNodeSnapshots.entries());
                return {
                    deletedNodeIds: Array.from(deletedNodeIds),
                    collapsedNodeIds: Array.from(collapsedNodeIds),
                    focusNodeId,
                    hiddenNodeSnapshots: hiddenEntries,
                    originalRows: JSON.parse(JSON.stringify(originalRows)),
                };
            };

            const applyState = (state) => {
                deletedNodeIds.clear();
                state.deletedNodeIds.forEach((id) => deletedNodeIds.add(id));
                collapsedNodeIds.clear();
                state.collapsedNodeIds.forEach((id) => collapsedNodeIds.add(id));
                focusNodeId = state.focusNodeId || "";
                hiddenNodeSnapshots.clear();
                state.hiddenNodeSnapshots.forEach(([id, html]) => hiddenNodeSnapshots.set(id, html));
                originalRows = JSON.parse(JSON.stringify(state.originalRows));
                selectedNodeId = "";
            };

            const pushUndoState = () => {
                undoStack.push(serializeState());
                redoStack.length = 0;
            };

            const updateUndoRedoButtons = () => {
                if (undoButton) {
                    undoButton.disabled = undoStack.length === 0;
                }
                if (redoButton) {
                    redoButton.disabled = redoStack.length === 0;
                }
            };

            const getNodeHtml = (row) => {
                const value = row[0];
                if (!value || typeof value !== "object" || !value.f) {
                    return "";
                }
                return value.f;
            };

            const setNodeHtml = (row, html) => {
                const value = row[0];
                if (!value || typeof value !== "object") {
                    return row;
                }
                return [
                    {
                        ...value,
                        f: html,
                    },
                    row[1],
                    row[2],
                ];
            };

            const buildHiddenHtml = (html) => {
                const wrapper = document.createElement("div");
                wrapper.innerHTML = html;
                const node = wrapper.querySelector(".org-chart-node");
                if (!node) {
                    return html;
                }
                const type = node.getAttribute("data-node-type") || "";
                const iconImg = node.querySelector(".org-chart-icon img");
                if (iconImg && type) {
                    iconImg.src = `/static/img/${type}_hidden.png`;
                }
                const text = node.querySelector(".org-chart-text");
                if (text) {
                    text.textContent = "<Hidden>";
                }
                return wrapper.innerHTML;
            };

            const getNodeId = (row) => {
                const value = row[0];
                if (typeof value === "string") {
                    return value;
                }
                return value && value.v ? value.v : "";
            };

            const buildChildrenMap = (rows) => {
                const map = {};
                rows.forEach((row) => {
                    const nodeId = getNodeId(row);
                    const parentId = row[1];
                    if (!parentId) {
                        return;
                    }
                    if (!map[parentId]) {
                        map[parentId] = [];
                    }
                    map[parentId].push(nodeId);
                });
                return map;
            };

            const buildChildCountMap = (rows) => {
                const counts = {};
                rows.forEach((row) => {
                    const parentId = row[1];
                    if (!parentId) {
                        return;
                    }
                    counts[parentId] = (counts[parentId] || 0) + 1;
                });
                return counts;
            };

            const getNodeTypeFromRow = (row) => {
                const value = row[0];
                if (!value || typeof value !== "object" || !value.f) {
                    return "";
                }
                const match = value.f.match(/data-node-type=\"([^\"]+)\"/);
                return match ? match[1] : "";
            };

            const getIconHtmlFromRow = (row) => {
                const value = row[0];
                if (!value || typeof value !== "object" || !value.f) {
                    return "";
                }
                const wrapper = document.createElement("div");
                wrapper.innerHTML = value.f;
                const icon = wrapper.querySelector(".org-chart-icon");
                return icon ? icon.innerHTML : "";
            };

            const buildTypeIconMap = (rows) => {
                const map = {};
                rows.forEach((row) => {
                    const type = getNodeTypeFromRow(row);
                    if (!type || map[type]) {
                        return;
                    }
                    const iconHtml = getIconHtmlFromRow(row);
                    if (iconHtml) {
                        map[type] = iconHtml;
                    }
                });
                return map;
            };

            const collectSubtree = (rootId, childrenMap) => {
                const toVisit = [rootId];
                const collected = new Set();
                while (toVisit.length > 0) {
                    const current = toVisit.pop();
                    if (!current || collected.has(current)) {
                        continue;
                    }
                    collected.add(current);
                    const kids = childrenMap[current] || [];
                    kids.forEach((kid) => toVisit.push(kid));
                }
                return collected;
            };

            const applyCountsToRows = (rows, allRows, countMap, collapsedSet, childrenMap, typeIconMap) => {
                return rows.map((row) => {
                    const nodeId = getNodeId(row);
                    if (!collapsedSet.has(nodeId)) {
                        return row;
                    }
                    const count = countMap[nodeId];
                    if (!count) {
                        return row;
                    }
                    const value = row[0];
                    if (typeof value !== "object" || !value.f) {
                        return row;
                    }
                    const subtree = collectSubtree(nodeId, childrenMap);
                    subtree.delete(nodeId);
                    const typeCounts = {};
                    allRows.forEach((candidate) => {
                        const candidateId = getNodeId(candidate);
                        if (!subtree.has(candidateId)) {
                            return;
                        }
                        const type = getNodeTypeFromRow(candidate);
                        if (!type) {
                            return;
                        }
                        typeCounts[type] = (typeCounts[type] || 0) + 1;
                    });
                    const orderedTypes = ["folder", "project"];
                    const summary = orderedTypes
                        .filter((type) => typeCounts[type])
                        .map((type) => {
                            const typeCount = typeCounts[type];
                            const iconHtml = typeIconMap[type] || "";
                            if (!iconHtml) {
                                return `<span class=\"org-chart-count\">${type}x${typeCount}</span>`;
                            }
                            return `<span class=\"org-chart-collapsed\">${iconHtml}<span class=\"org-chart-mult\">x${typeCount}</span></span>`;
                        })
                        .join(" ");
                    if (!summary) {
                        return row;
                    }
                    const updated = value.f.replace(
                        /(<div class=\"org-chart-text\">)([\s\S]*?)(<\/div>)/,
                        `$1$2<br><span class=\"org-chart-summary\">${summary}</span>$3`
                    );
                    return [
                        {
                            ...value,
                            f: updated,
                        },
                        row[1],
                        row[2],
                    ];
                });
            };

            const buildVisibleRows = () => {
                let rows = originalRows.filter((row) => !deletedNodeIds.has(getNodeId(row)));
                const childrenMap = buildChildrenMap(rows);
                if (focusNodeId) {
                    const focusedSet = collectSubtree(focusNodeId, childrenMap);
                    rows = rows.filter((row) => focusedSet.has(getNodeId(row)));
                }
                collapsedNodeIds.forEach((collapsedId) => {
                    const toHide = collectSubtree(collapsedId, childrenMap);
                    toHide.delete(collapsedId);
                    rows = rows.filter((row) => !toHide.has(getNodeId(row)));
                });
                return rows;
            };

            const renderChart = () => {
                currentRows = buildVisibleRows();
                const visibleRows = originalRows.filter((row) => !deletedNodeIds.has(getNodeId(row)));
                const countMap = buildChildCountMap(visibleRows);
                const childrenMap = buildChildrenMap(visibleRows);
                const typeIconMap = buildTypeIconMap(visibleRows);
                const rowsWithCounts = applyCountsToRows(currentRows, visibleRows, countMap, collapsedNodeIds, childrenMap, typeIconMap);
                const data = buildDataTable(rowsWithCounts);
                if (data.getNumberOfRows() === 0) {
                    container.innerHTML = "";
                    deleteButton.disabled = true;
                    restoreButton.disabled = currentRows.length === originalRows.length;
                    if (saveButton) {
                        saveButton.disabled = true;
                    }
                    if (focusButton) {
                        focusButton.disabled = true;
                    }
                    if (searchInput) {
                        searchInput.value = "";
                        searchInput.disabled = true;
                    }
                    return;
                }

                chart = new google.visualization.OrgChart(container);
                google.visualization.events.addListener(chart, 'select', () => {
                    const selection = chart.getSelection();
                    if (!selection.length) {
                        selectedNodeId = "";
                        clearSelectionHighlight();
                        deleteButton.disabled = true;
                        if (focusButton) {
                            focusButton.disabled = true;
                        }
                        if (toggleButton) {
                            toggleButton.disabled = true;
                            toggleButton.textContent = "Hide";
                        }
                        return;
                    }
                    const rowIndex = selection[0].row;
                    if (rowIndex === null || rowIndex === undefined) {
                        selectedNodeId = "";
                        clearSelectionHighlight();
                        deleteButton.disabled = true;
                        if (focusButton) {
                            focusButton.disabled = true;
                        }
                        if (toggleButton) {
                            toggleButton.disabled = true;
                            toggleButton.textContent = "Hide";
                        }
                        return;
                    }
                    selectedNodeId = getNodeId(currentRows[rowIndex]);
                    applySelectionHighlight();
                    deleteButton.disabled = !selectedNodeId;
                    if (focusButton) {
                        focusButton.disabled = !selectedNodeId;
                    }
                    if (toggleButton) {
                        toggleButton.disabled = !selectedNodeId;
                        toggleButton.textContent = hiddenNodeSnapshots.has(selectedNodeId) ? "Show" : "Hide";
                    }
                });
                chart.draw(data, { allowHtml: true });

                applySelectionHighlight();

                if (searchInput) {
                    searchInput.disabled = false;
                    highlightSearchMatches(searchInput.value);
                }

                requestAnimationFrame(() => {
                    updateCanvasSize();
                });

                deleteButton.disabled = !selectedNodeId;
                if (focusButton) {
                    focusButton.disabled = !selectedNodeId;
                }
                restoreButton.disabled = currentRows.length === originalRows.length;
                if (saveButton) {
                    saveButton.disabled = currentRows.length === 0;
                }
                if (toggleButton) {
                    toggleButton.disabled = !selectedNodeId;
                    toggleButton.textContent = hiddenNodeSnapshots.has(selectedNodeId) ? "Show" : "Hide";
                }
                updateUndoRedoButtons();
            };

            const highlightSearchMatches = (query) => {
                const term = (query || "").trim().toLowerCase();
                const nodes = container.querySelectorAll(".org-chart-node");
                nodes.forEach((node) => {
                    node.classList.remove("org-chart-highlight");
                    if (!term) {
                        return;
                    }
                    const text = node.textContent ? node.textContent.toLowerCase() : "";
                    if (text.includes(term)) {
                        node.classList.add("org-chart-highlight");
                    }
                });
            };

            deleteButton.addEventListener("click", () => {
                if (!selectedNodeId) {
                    return;
                }
                pushUndoState();
                const childrenMap = buildChildrenMap(originalRows.filter((row) => !deletedNodeIds.has(getNodeId(row))));
                const toRemove = collectSubtree(selectedNodeId, childrenMap);
                toRemove.forEach((nodeId) => deletedNodeIds.add(nodeId));
                selectedNodeId = "";
                renderChart();
            });

            if (toggleButton) {
                toggleButton.addEventListener("click", () => {
                    if (!selectedNodeId) {
                        return;
                    }
                    pushUndoState();
                    const rowIndex = originalRows.findIndex((row) => getNodeId(row) === selectedNodeId);
                    if (rowIndex === -1) {
                        return;
                    }
                    const currentRow = originalRows[rowIndex];
                    const currentHtml = getNodeHtml(currentRow);
                    if (!currentHtml) {
                        return;
                    }
                    if (hiddenNodeSnapshots.has(selectedNodeId)) {
                        const originalHtml = hiddenNodeSnapshots.get(selectedNodeId);
                        originalRows[rowIndex] = setNodeHtml(currentRow, originalHtml);
                        hiddenNodeSnapshots.delete(selectedNodeId);
                    } else {
                        hiddenNodeSnapshots.set(selectedNodeId, currentHtml);
                        const hiddenHtml = buildHiddenHtml(currentHtml);
                        originalRows[rowIndex] = setNodeHtml(currentRow, hiddenHtml);
                    }
                    renderChart();
                });
            }

            if (undoButton) {
                undoButton.addEventListener("click", () => {
                    if (undoStack.length === 0) {
                        return;
                    }
                    redoStack.push(serializeState());
                    const previous = undoStack.pop();
                    applyState(previous);
                    renderChart();
                });
            }

            if (redoButton) {
                redoButton.addEventListener("click", () => {
                    if (redoStack.length === 0) {
                        return;
                    }
                    undoStack.push(serializeState());
                    const next = redoStack.pop();
                    applyState(next);
                    renderChart();
                });
            }

            restoreButton.addEventListener("click", () => {
                pushUndoState();
                deletedNodeIds.clear();
                collapsedNodeIds.clear();
                selectedNodeId = "";
                focusNodeId = "";
                if (hiddenNodeSnapshots.size > 0) {
                    originalRows = originalRows.map((row) => {
                        const nodeId = getNodeId(row);
                        if (hiddenNodeSnapshots.has(nodeId)) {
                            return setNodeHtml(row, hiddenNodeSnapshots.get(nodeId));
                        }
                        return row;
                    });
                    hiddenNodeSnapshots.clear();
                }
                renderChart();
            });

            if (saveButton) {
                saveButton.addEventListener("click", async () => {
                    const chartRoot = document.getElementById("resource-hierarchy-chart-scale");
                    const chartElement = document.getElementById("resource-hierarchy-chart");
                    if (!chartRoot || !chartElement) {
                        return;
                    }
                    saveButton.disabled = true;
                    const previousTransform = chartRoot.style.transform;
                    const previousWidth = chartElement.style.width;
                    const previousHeight = chartElement.style.height;
                    try {
                        chartRoot.style.transform = "none";
                        const fullWidth = Math.max(chartElement.scrollWidth, chartElement.offsetWidth, chartElement.clientWidth);
                        const fullHeight = Math.max(chartElement.scrollHeight, chartElement.offsetHeight, chartElement.clientHeight);
                        chartElement.style.width = `${fullWidth}px`;
                        chartElement.style.height = `${fullHeight}px`;
                        const isDarkTheme = document.body.getAttribute("data-theme") === "dark";
                        const canvas = await html2canvas(chartElement, {
                            backgroundColor: isDarkTheme ? "#0b1120" : "#ffffff",
                            useCORS: true,
                            scale: 2,
                            width: fullWidth,
                            height: fullHeight,
                            windowWidth: fullWidth,
                            windowHeight: fullHeight,
                            scrollX: 0,
                            scrollY: 0,
                            onclone: (clonedDoc) => {
                                if (isDarkTheme) {
                                    clonedDoc.body.setAttribute("data-theme", "dark");
                                }
                                clonedDoc
                                    .querySelectorAll(".org-chart-highlight")
                                    .forEach((node) => node.classList.remove("org-chart-highlight"));
                                clonedDoc
                                    .querySelectorAll(".google-visualization-orgchart-node-selected")
                                    .forEach((node) => node.classList.remove("google-visualization-orgchart-node-selected"));
                                clonedDoc
                                    .querySelectorAll(".org-chart-node.node-selected")
                                    .forEach((node) => node.classList.remove("node-selected"));
                                clonedDoc
                                    .querySelectorAll("#resource-hierarchy-chart-scale, #resource-hierarchy-chart, .google-visualization-orgchart-node")
                                    .forEach((node) => {
                                        node.style.boxShadow = "none";
                                        node.style.filter = "none";
                                    });
                            },
                        });
                        const link = document.createElement("a");
                        const safeId = (resourceIdValue || "chart").replace(/[^a-zA-Z0-9_-]+/g, "_");
                        link.download = `chart_${safeId}.png`;
                        link.href = canvas.toDataURL("image/png");
                        link.click();
                    } catch (err) {
                        console.error("Failed to save chart", err);
                    } finally {
                        chartRoot.style.transform = previousTransform;
                        chartElement.style.width = previousWidth;
                        chartElement.style.height = previousHeight;
                        saveButton.disabled = currentRows.length === 0;
                    }
                });
            }

            if (focusButton) {
                focusButton.addEventListener("click", () => {
                    if (!selectedNodeId) {
                        return;
                    }
                    pushUndoState();
                    focusNodeId = selectedNodeId;
                    renderChart();
                });
            }

            if (searchInput) {
                searchInput.addEventListener("input", (event) => {
                    highlightSearchMatches(event.target.value);
                });
            }

            container.addEventListener("dblclick", (event) => {
                const nodeElement = event.target.closest(".org-chart-node");
                const nodeId = nodeElement ? nodeElement.getAttribute("data-node-id") : "";
                if (!nodeId) {
                    return;
                }
                pushUndoState();
                if (collapsedNodeIds.has(nodeId)) {
                    collapsedNodeIds.delete(nodeId);
                } else {
                    collapsedNodeIds.add(nodeId);
                }
                selectedNodeId = nodeId;
                deleteButton.disabled = !selectedNodeId;
                if (focusButton) {
                    focusButton.disabled = !selectedNodeId;
                }
                renderChart();
            });

            renderChart();

            const scaleWrapper = document.getElementById("resource-hierarchy-chart-scale");
            const chartWrapper = scaleWrapper;
            let zoomLevel = 1;
            let panX = 0;
            let panY = 0;

            const updateCanvasSize = () => {
                const chartElement = document.getElementById("resource-hierarchy-chart");
                if (!chartElement || !scaleWrapper || !chartWrapper) {
                    return;
                }
                chartWrapper.style.setProperty("width", "100%", "important");
            };

            const applyZoom = () => {
                scaleWrapper.style.transform = `translate(${panX}px, ${panY}px) scale(${zoomLevel})`;
                updateCanvasSize();
            };

            applyZoom();

            const chartElement = document.getElementById("resource-hierarchy-chart");
            if (chartElement && typeof ResizeObserver !== "undefined") {
                const observer = new ResizeObserver(() => {
                    updateCanvasSize();
                });
                observer.observe(chartElement);
            }

            if (chartWrapper) {
                let isDragging = false;
                let startX = 0;
                let startY = 0;
                let startPanX = 0;
                let startPanY = 0;

                chartWrapper.addEventListener("mousedown", (event) => {
                    if (event.button !== 0) {
                        return;
                    }
                    isDragging = true;
                    startX = event.clientX;
                    startY = event.clientY;
                    startPanX = panX;
                    startPanY = panY;
                    chartWrapper.style.cursor = "grabbing";
                    event.preventDefault();
                });

                chartWrapper.addEventListener("mousemove", (event) => {
                    if (!isDragging) {
                        return;
                    }
                    const dx = event.clientX - startX;
                    const dy = event.clientY - startY;
                    panX = startPanX + dx;
                    panY = startPanY + dy;
                    applyZoom();
                });

                const stopDrag = () => {
                    if (!isDragging) {
                        return;
                    }
                    isDragging = false;
                    chartWrapper.style.cursor = "grab";
                };

                chartWrapper.addEventListener("mouseup", stopDrag);
                chartWrapper.addEventListener("mouseleave", stopDrag);

                chartWrapper.addEventListener("wheel", (event) => {
                    event.preventDefault();
                    const delta = Math.sign(event.deltaY);
                    const zoomFactor = delta > 0 ? 0.9 : 1.1;
                    const rect = chartWrapper.getBoundingClientRect();
                    const mouseX = event.clientX - rect.left;
                    const mouseY = event.clientY - rect.top;

                    const nextZoom = Math.min(2, Math.max(0.1, zoomLevel * zoomFactor));
                    const scaleChange = nextZoom / zoomLevel;

                    panX = mouseX - scaleChange * (mouseX - panX);
                    panY = mouseY - scaleChange * (mouseY - panY);
                    zoomLevel = Number(nextZoom.toFixed(2));
                    applyZoom();
                }, { passive: false });
            }

            document.getElementById("report").style.visibility = "visible";
            document.getElementById('loading').style.display = 'none';
        }

        google.charts.load('current', { packages: ['orgchart'] });
        google.charts.setOnLoadCallback(drawOrgChart);

        const resourceInput = document.getElementById("resourceId");
        const configForm = document.getElementById("config_form");
        if (resourceInput && configForm) {
            resourceInput.addEventListener("keydown", (event) => {
                if (event.key === "Enter") {
                    event.preventDefault();
                    if (showLoadingSpinner()) {
                        configForm.submit();
                    }
                }
            });
        }

        const themeToggle = document.getElementById("theme-toggle");
        const applyTheme = (mode) => {
            document.body.setAttribute("data-theme", mode);
            if (themeToggle) {
                themeToggle.textContent = mode === "dark" ? "â˜€ï¸" : "ðŸŒ™";
                themeToggle.setAttribute("aria-label", mode === "dark" ? "Switch to light mode" : "Switch to dark mode");
                themeToggle.setAttribute("title", mode === "dark" ? "Switch to light mode" : "Switch to dark mode");
            }
            localStorage.setItem("theme", mode);
        };

        if (themeToggle) {
            const savedTheme = localStorage.getItem("theme") || "light";
            applyTheme(savedTheme);
            themeToggle.addEventListener("click", () => {
                const current = document.body.getAttribute("data-theme") || "light";
                applyTheme(current === "dark" ? "light" : "dark");
            });
        }



        
    </script>

</body>
</html>