<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/x-icon" href="/static/favicon.png">
    <title>Google Cloud Health Check</title>
    <script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>
    <link rel="stylesheet" href="/static/style.css">
</head>
<body>
    <header>
        <div class="left">
            <img src="/static/favicon.png" width="40" height="40">
            <h2>Google Cloud Resource Hierarchy</h2>
        </div>

        <div id="controls">
            <span style="padding-right: 20px">User: {{ current_account }} </span><br>
            <button id="saveBtn" onclick="printReport()">Print report</button>
        </div>
    </header>
    <config>
        <div id="config-div" class="configDiv">
            <form method="get" id="config_form" action="/" style="display: inline;" onsubmit="return showLoadingSpinner();">
                <section class="form-row">
                    <label for="resourceId"><b>Resource ID:</b></label>
                    <input type="text" class="section-input" id="resourceId" name="resourceId" autofocus value="{{ resource_id }}"  style="width: 17em">
                    <label for="search-input"><b>Search:</b></label>
                    <input type="text" id="search-input" class="search-input" disabled>
                    <button id="focus-node" type="button" style="margin-left: 8px;" disabled>Focus item</button>
                    <button id="delete-node" type="button" style="margin-left: 8px;" disabled>Delete item</button>
                    <button id="restore-chart" type="button" style="margin-left: 6px;" disabled>Restore chart</button>
                </section>
                <section>
                    <span id="error_msg" style="color: red;vertical-align: top;visibility: hidden;">{{error_msg|safe}}</span>
                </section>
            </form>
            <hr>
        </div>
    </config>
    <main>
        <div id="loading">
            <p>Loading, please wait...</p>
            <img src="{{ url_for('static', filename='loading.gif') }}" alt="Loading...">
        </div>
        <div id="report" style="visibility: hidden;">
            <div id="resource-hierarchy-chart-scale">
                <div id="resource-hierarchy-chart"></div>
            </div>
        </div>
        

    </main>
    <br><hr><br>

    <script>
        // SHOW LOADING ////////////////////////////////////////////

        function showLoadingSpinner() {
            document.getElementById('error_msg').style.visibility = 'hidden';
            document.getElementById("report").style.visibility = "hidden";   
            document.getElementById('loading').style.display = 'block';

            return true;
        }

        // ORG CHART //////////////////////////////////////////////

        function drawOrgChart() {
            const container = document.getElementById('resource-hierarchy-chart');
            if (!container) {
                return;
            }

            const deleteButton = document.getElementById("delete-node");
            const restoreButton = document.getElementById("restore-chart");
            const searchInput = document.getElementById("search-input");
            const focusButton = document.getElementById("focus-node");

            const chartDataRaw = {{ resource_hierarchy_chart_data|tojson|safe }};
            let originalRows = [];
            if (chartDataRaw) {
                try {
                    originalRows = JSON.parse(chartDataRaw);
                } catch (err) {
                    console.error("Failed to parse chart data JSON", err);
                }
            }

            let currentRows = originalRows.slice();
            let selectedNodeId = "";
            const deletedNodeIds = new Set();
            const collapsedNodeIds = new Set();
            let focusNodeId = "";

            let chart = null;

            const buildDataTable = (rows) => {
                var data = new google.visualization.DataTable();
                data.addColumn('string', 'Name');
                data.addColumn('string', 'Manager');
                data.addColumn('string', 'ToolTip');
                if (rows.length > 0) {
                    data.addRows(rows);
                }
                return data;
            };

            const getNodeId = (row) => {
                const value = row[0];
                if (typeof value === "string") {
                    return value;
                }
                return value && value.v ? value.v : "";
            };

            const buildChildrenMap = (rows) => {
                const map = {};
                rows.forEach((row) => {
                    const nodeId = getNodeId(row);
                    const parentId = row[1];
                    if (!parentId) {
                        return;
                    }
                    if (!map[parentId]) {
                        map[parentId] = [];
                    }
                    map[parentId].push(nodeId);
                });
                return map;
            };

            const buildChildCountMap = (rows) => {
                const counts = {};
                rows.forEach((row) => {
                    const parentId = row[1];
                    if (!parentId) {
                        return;
                    }
                    counts[parentId] = (counts[parentId] || 0) + 1;
                });
                return counts;
            };

            const collectSubtree = (rootId, childrenMap) => {
                const toVisit = [rootId];
                const collected = new Set();
                while (toVisit.length > 0) {
                    const current = toVisit.pop();
                    if (!current || collected.has(current)) {
                        continue;
                    }
                    collected.add(current);
                    const kids = childrenMap[current] || [];
                    kids.forEach((kid) => toVisit.push(kid));
                }
                return collected;
            };

            const applyCountsToRows = (rows, countMap, collapsedSet) => {
                return rows.map((row) => {
                    const nodeId = getNodeId(row);
                    if (!collapsedSet.has(nodeId)) {
                        return row;
                    }
                    const count = countMap[nodeId];
                    if (!count) {
                        return row;
                    }
                    const value = row[0];
                    if (typeof value !== "object" || !value.f) {
                        return row;
                    }
                    const updated = value.f.replace(
                        /(<div class=\"org-chart-text\">)([\s\S]*?)(<\/div>)/,
                        `$1$2 <span class=\"org-chart-count\">(${count})<\/span>$3`
                    );
                    return [
                        {
                            ...value,
                            f: updated,
                        },
                        row[1],
                        row[2],
                    ];
                });
            };

            const buildVisibleRows = () => {
                let rows = originalRows.filter((row) => !deletedNodeIds.has(getNodeId(row)));
                const childrenMap = buildChildrenMap(rows);
                if (focusNodeId) {
                    const focusedSet = collectSubtree(focusNodeId, childrenMap);
                    rows = rows.filter((row) => focusedSet.has(getNodeId(row)));
                }
                collapsedNodeIds.forEach((collapsedId) => {
                    const toHide = collectSubtree(collapsedId, childrenMap);
                    toHide.delete(collapsedId);
                    rows = rows.filter((row) => !toHide.has(getNodeId(row)));
                });
                return rows;
            };

            const renderChart = () => {
                currentRows = buildVisibleRows();
                const countMap = buildChildCountMap(originalRows.filter((row) => !deletedNodeIds.has(getNodeId(row))));
                const rowsWithCounts = applyCountsToRows(currentRows, countMap, collapsedNodeIds);
                const data = buildDataTable(rowsWithCounts);
                if (data.getNumberOfRows() === 0) {
                    container.innerHTML = "";
                    deleteButton.disabled = true;
                    restoreButton.disabled = currentRows.length === originalRows.length;
                    if (focusButton) {
                        focusButton.disabled = true;
                    }
                    if (searchInput) {
                        searchInput.value = "";
                        searchInput.disabled = true;
                    }
                    return;
                }

                chart = new google.visualization.OrgChart(container);
                google.visualization.events.addListener(chart, 'select', () => {
                    const selection = chart.getSelection();
                    if (!selection.length) {
                        selectedNodeId = "";
                        deleteButton.disabled = true;
                        if (focusButton) {
                            focusButton.disabled = true;
                        }
                        return;
                    }
                    const rowIndex = selection[0].row;
                    if (rowIndex === null || rowIndex === undefined) {
                        selectedNodeId = "";
                        deleteButton.disabled = true;
                        if (focusButton) {
                            focusButton.disabled = true;
                        }
                        return;
                    }
                    selectedNodeId = getNodeId(currentRows[rowIndex]);
                    deleteButton.disabled = !selectedNodeId;
                    if (focusButton) {
                        focusButton.disabled = !selectedNodeId;
                    }
                });
                chart.draw(data, { allowHtml: true });

                if (searchInput) {
                    searchInput.disabled = false;
                    highlightSearchMatches(searchInput.value);
                }

                requestAnimationFrame(() => {
                    updateCanvasSize();
                });

                deleteButton.disabled = !selectedNodeId;
                if (focusButton) {
                    focusButton.disabled = !selectedNodeId;
                }
                restoreButton.disabled = currentRows.length === originalRows.length;
            };

            const highlightSearchMatches = (query) => {
                const term = (query || "").trim().toLowerCase();
                const nodes = container.querySelectorAll(".org-chart-node");
                nodes.forEach((node) => {
                    node.classList.remove("org-chart-highlight");
                    if (!term) {
                        return;
                    }
                    const text = node.textContent ? node.textContent.toLowerCase() : "";
                    if (text.includes(term)) {
                        node.classList.add("org-chart-highlight");
                    }
                });
            };

            deleteButton.addEventListener("click", () => {
                if (!selectedNodeId) {
                    return;
                }
                const childrenMap = buildChildrenMap(originalRows.filter((row) => !deletedNodeIds.has(getNodeId(row))));
                const toRemove = collectSubtree(selectedNodeId, childrenMap);
                toRemove.forEach((nodeId) => deletedNodeIds.add(nodeId));
                selectedNodeId = "";
                renderChart();
            });

            restoreButton.addEventListener("click", () => {
                deletedNodeIds.clear();
                collapsedNodeIds.clear();
                selectedNodeId = "";
                focusNodeId = "";
                renderChart();
            });

            if (focusButton) {
                focusButton.addEventListener("click", () => {
                    if (!selectedNodeId) {
                        return;
                    }
                    focusNodeId = selectedNodeId;
                    renderChart();
                });
            }

            if (searchInput) {
                searchInput.addEventListener("input", (event) => {
                    highlightSearchMatches(event.target.value);
                });
            }

            container.addEventListener("dblclick", (event) => {
                const nodeElement = event.target.closest(".org-chart-node");
                const nodeId = nodeElement ? nodeElement.getAttribute("data-node-id") : "";
                if (!nodeId) {
                    return;
                }
                if (collapsedNodeIds.has(nodeId)) {
                    collapsedNodeIds.delete(nodeId);
                } else {
                    collapsedNodeIds.add(nodeId);
                }
                selectedNodeId = nodeId;
                deleteButton.disabled = !selectedNodeId;
                if (focusButton) {
                    focusButton.disabled = !selectedNodeId;
                }
                renderChart();
            });

            renderChart();

            const scaleWrapper = document.getElementById("resource-hierarchy-chart-scale");
            const chartWrapper = scaleWrapper;
            let zoomLevel = 1;
            let panX = 0;
            let panY = 0;

            const updateCanvasSize = () => {
                const chartElement = document.getElementById("resource-hierarchy-chart");
                if (!chartElement || !scaleWrapper || !chartWrapper) {
                    return;
                }
                chartWrapper.style.setProperty("width", "100%", "important");
            };

            const applyZoom = () => {
                scaleWrapper.style.transform = `translate(${panX}px, ${panY}px) scale(${zoomLevel})`;
                updateCanvasSize();
            };

            applyZoom();

            const chartElement = document.getElementById("resource-hierarchy-chart");
            if (chartElement && typeof ResizeObserver !== "undefined") {
                const observer = new ResizeObserver(() => {
                    updateCanvasSize();
                });
                observer.observe(chartElement);
            }

            if (chartWrapper) {
                let isDragging = false;
                let startX = 0;
                let startY = 0;
                let startPanX = 0;
                let startPanY = 0;

                chartWrapper.addEventListener("mousedown", (event) => {
                    if (event.button !== 0) {
                        return;
                    }
                    isDragging = true;
                    startX = event.clientX;
                    startY = event.clientY;
                    startPanX = panX;
                    startPanY = panY;
                    chartWrapper.style.cursor = "grabbing";
                    event.preventDefault();
                });

                chartWrapper.addEventListener("mousemove", (event) => {
                    if (!isDragging) {
                        return;
                    }
                    const dx = event.clientX - startX;
                    const dy = event.clientY - startY;
                    panX = startPanX + dx;
                    panY = startPanY + dy;
                    applyZoom();
                });

                const stopDrag = () => {
                    if (!isDragging) {
                        return;
                    }
                    isDragging = false;
                    chartWrapper.style.cursor = "grab";
                };

                chartWrapper.addEventListener("mouseup", stopDrag);
                chartWrapper.addEventListener("mouseleave", stopDrag);

                chartWrapper.addEventListener("wheel", (event) => {
                    event.preventDefault();
                    const delta = Math.sign(event.deltaY);
                    const zoomFactor = delta > 0 ? 0.9 : 1.1;
                    const rect = chartWrapper.getBoundingClientRect();
                    const mouseX = event.clientX - rect.left;
                    const mouseY = event.clientY - rect.top;

                    const nextZoom = Math.min(2, Math.max(0.1, zoomLevel * zoomFactor));
                    const scaleChange = nextZoom / zoomLevel;

                    panX = mouseX - scaleChange * (mouseX - panX);
                    panY = mouseY - scaleChange * (mouseY - panY);
                    zoomLevel = Number(nextZoom.toFixed(2));
                    applyZoom();
                }, { passive: false });
            }

            document.getElementById("report").style.visibility = "visible";
            document.getElementById('loading').style.display = 'none';
        }

        google.charts.load('current', { packages: ['orgchart'] });
        google.charts.setOnLoadCallback(drawOrgChart);



        
    </script>

</body>
</html>